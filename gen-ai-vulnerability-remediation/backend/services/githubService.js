/**
 * GitHub Service
 * Handles integration with GitHub API for repository cloning and analysis
 */

const axios = require('axios');
const { exec } = require('child_process');
const util = require('util');
const execPromise = util.promisify(exec);
const fs = require('fs');
const path = require('path');

// GitHub API configuration
const githubConfig = {
  token: process.env.GITHUB_TOKEN || '',
  apiUrl: 'https://api.github.com',
  tempDir: process.env.TEMP_DIR || './temp'
};

/**
 * Clone a GitHub repository
 * @param {string} repoUrl - GitHub repository URL
 * @returns {Object} Clone information
 */
const cloneRepository = async (repoUrl) => {
  try {
    // Extract owner and repo name from URL
    // Format: https://github.com/owner/repo
    const urlParts = repoUrl.split('/');
    const owner = urlParts[urlParts.length - 2];
    const repo = urlParts[urlParts.length - 1].replace('.git', '');
    
    // Create a unique directory for this clone
    const cloneDir = path.join(githubConfig.tempDir, `${owner}-${repo}-${Date.now()}`);
    
    // Ensure temp directory exists
    if (!fs.existsSync(githubConfig.tempDir)) {
      fs.mkdirSync(githubConfig.tempDir, { recursive: true });
    }
    
    // Clone the repository
    let cloneCommand = `git clone ${repoUrl} ${cloneDir}`;
    
    // Use token if available
    if (githubConfig.token) {
      const tokenUrl = repoUrl.replace('https://', `https://${githubConfig.token}@`);
      cloneCommand = `git clone ${tokenUrl} ${cloneDir}`;
    }
    
    await execPromise(cloneCommand);
    
    return {
      success: true,
      cloneDir,
      owner,
      repo
    };
  } catch (error) {
    console.error('Error cloning repository:', error);
    throw new Error(`Failed to clone repository: ${error.message}`);
  }
};

/**
 * Get repository information from GitHub API
 * @param {string} owner - Repository owner
 * @param {string} repo - Repository name
 * @returns {Object} Repository information
 */
const getRepositoryInfo = async (owner, repo) => {
  try {
    const headers = {};
    if (githubConfig.token) {
      headers.Authorization = `token ${githubConfig.token}`;
    }
    
    const response = await axios.get(`${githubConfig.apiUrl}/repos/${owner}/${repo}`, {
      headers
    });
    
    return {
      id: response.data.id,
      name: response.data.name,
      fullName: response.data.full_name,
      description: response.data.description,
      language: response.data.language,
      defaultBranch: response.data.default_branch,
      stars: response.data.stargazers_count,
      forks: response.data.forks_count,
      openIssues: response.data.open_issues_count,
      createdAt: response.data.created_at,
      updatedAt: response.data.updated_at
    };
  } catch (error) {
    console.error('Error getting repository info:', error);
    throw new Error(`Failed to get repository info: ${error.message}`);
  }
};

/**
 * Clean up cloned repository
 * @param {string} cloneDir - Directory where repository was cloned
 */
const cleanupRepository = async (cloneDir) => {
  try {
    if (fs.existsSync(cloneDir)) {
      // Use rimraf or fs-extra for better directory removal
      fs.rmSync(cloneDir, { recursive: true, force: true });
    }
    
    return {
      success: true,
      message: 'Repository cleaned up successfully'
    };
  } catch (error) {
    console.error('Error cleaning up repository:', error);
    throw new Error(`Failed to clean up repository: ${error.message}`);
  }
};

module.exports = {
  cloneRepository,
  getRepositoryInfo,
  cleanupRepository
};