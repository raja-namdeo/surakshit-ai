/**
 * Scan Service
 * Handles vulnerability scanning operations
 */

const { v4: uuidv4 } = require('uuid');
const axios = require('axios');
const { exec } = require('child_process');
const util = require('util');
const execPromise = util.promisify(exec);
const zapService = require('./zapService');
const scanProfiles = require('../config/scanProfiles');

// Mock database for MVP
const scanResults = [];

/**
 * Perform a vulnerability scan on the target
 * @param {string} target - URL or codebase path to scan
 * @param {string} scanType - Type of scan (full, quick, custom)
 * @param {string} profileName - Name of the scan profile to use
 * @param {Object} customParams - Custom scan parameters to override profile defaults
 * @returns {Object} Scan results
 */
const performScan = async (target, scanType = 'full', profileName = 'webApp', customParams = {}) => {
  try {
    console.log(`Starting ${scanType} scan on ${target} using profile ${profileName}`);
    
    // Generate a unique ID for this scan
    const scanId = uuidv4();
    const timestamp = new Date().toISOString();
    
    // Get scan profile
    const profile = scanProfiles.getScanProfile(profileName);
    
    // Merge custom parameters with profile parameters
    const scanParams = {
      ...profile.params,
      ...customParams
    };
    
    // Create scan result object
    const scanResult = {
      id: scanId,
      target,
      scanType,
      profileName,
      timestamp,
      status: 'in-progress',
      vulnerabilities: []
    };
    
    // Store in our mock database
    scanResults.push(scanResult);
    
    // Check if we should use real scanning or mock data
    const useRealScan = process.env.USE_REAL_SCAN === 'true' && target.startsWith('http');
    
    if (useRealScan) {
      // Perform real scan using ZAP
      try {
        // Initialize ZAP session
        await zapService.initializeSession();
        
        // Configure scanners based on profile
        await zapService.configureScanners(scanParams.scanners);
        
        // Set scan policy
        await zapService.setScanPolicy({
          attackStrength: scanParams.attackStrength || 'medium',
          alertThreshold: scanParams.threshold || 'medium'
        });
        
        // Start spider scan
        const spiderResult = await zapService.startSpiderScan(target, {
          maxDepth: scanParams.maxDepth
        });
        
        // Wait for spider scan to complete
        let spiderStatus = { completed: false };
        while (!spiderStatus.completed) {
          await new Promise(resolve => setTimeout(resolve, 5000)); // Wait 5 seconds
          spiderStatus = await zapService.checkScanStatus(spiderResult.scanId, 'spider');
          console.log(`Spider scan progress: ${spiderStatus.progress}`);
        }
        
        // Start AJAX spider if enabled
        if (scanParams.ajaxSpider) {
          await zapService.startAjaxSpiderScan(target);
          
          // Wait for AJAX spider to complete
          let ajaxRunning = true;
          while (ajaxRunning) {
            await new Promise(resolve => setTimeout(resolve, 5000)); // Wait 5 seconds
            ajaxRunning = await zapService.isAjaxSpiderRunning();
            console.log(`AJAX spider running: ${ajaxRunning}`);
          }
        }
        
        // Start active scan if enabled
        if (scanParams.includeActive) {
          const activeScanResult = await zapService.startActiveScan(target);
          
          // Wait for active scan to complete
          let activeScanStatus = { completed: false };
          while (!activeScanStatus.completed) {
            await new Promise(resolve => setTimeout(resolve, 5000)); // Wait 5 seconds
            activeScanStatus = await zapService.checkScanStatus(activeScanResult.scanId, 'ascan');
            console.log(`Active scan progress: ${activeScanStatus.progress}`);
          }
        }
        
        // Get scan results
        const vulnerabilities = await zapService.getScanResults();
        
        // Update scan result
        const index = scanResults.findIndex(scan => scan.id === scanId);
        if (index !== -1) {
          scanResults[index].vulnerabilities = vulnerabilities;
          scanResults[index].status = 'completed';
        }
        
        return scanResults[index];
      } catch (error) {
        console.error('Error performing real scan:', error);
        
        // Update scan result with error
        const index = scanResults.findIndex(scan => scan.id === scanId);
        if (index !== -1) {
          scanResults[index].status = 'failed';
          scanResults[index].error = error.message;
        }
        
        // Fall back to mock data
        console.log('Falling back to mock data');
      }
    }
    
    // For MVP or if real scan failed, we'll use mock data
    let vulnerabilities = [];
    
    // Simulate different scan types
    if (scanType === 'quick') {
      // Quick scan finds fewer vulnerabilities
      vulnerabilities = getMockVulnerabilities(2);
    } else if (scanType === 'full') {
      // Full scan finds more vulnerabilities
      vulnerabilities = getMockVulnerabilities(5);
    } else {
      // Custom scan
      vulnerabilities = getMockVulnerabilities(3);
    }
    
    // Update scan result
    const index = scanResults.findIndex(scan => scan.id === scanId);
    if (index !== -1) {
      scanResults[index].vulnerabilities = vulnerabilities;
      scanResults[index].status = 'completed';
    }
    
    return scanResults[index];
  } catch (error) {
    console.error('Error performing scan:', error);
    throw new Error(`Scan failed: ${error.message}`);
  }
};

/**
 * Get scan history
 * @returns {Array} List of past scans
 */
const getScanHistory = async () => {
  // In a real implementation, this would query a database
  return scanResults.map(scan => ({
    id: scan.id,
    target: scan.target,
    scanType: scan.scanType,
    profileName: scan.profileName,
    timestamp: scan.timestamp,
    status: scan.status,
    vulnerabilityCount: scan.vulnerabilities ? scan.vulnerabilities.length : 0
  }));
};

/**
 * Get scan by ID
 * @param {string} scanId - ID of the scan to retrieve
 * @returns {Object} Scan result
 */
const getScanById = async (scanId) => {
  // In a real implementation, this would query a database
  return scanResults.find(scan => scan.id === scanId);
};

/**
 * Get available scan profiles
 * @returns {Array} List of available scan profiles
 */
const getScanProfiles = async () => {
  return scanProfiles.getAllScanProfiles();
};

/**
 * Generate mock vulnerabilities for demo purposes
 * @param {number} count - Number of vulnerabilities to generate
 * @returns {Array} List of mock vulnerabilities
 */
const getMockVulnerabilities = (count) => {
  const vulnerabilityTypes = [
    {
      type: 'SQL Injection',
      severity: 'high',
      description: 'Unsanitized user input in SQL query',
      locations: ['/api/users', '/api/products', '/api/orders']
    },
    {
      type: 'Cross-Site Scripting (XSS)',
      severity: 'medium',
      description: 'Reflected XSS vulnerability in user input',
      locations: ['/views/profile.html', '/views/comments.js', '/public/scripts.js']
    },
    {
      type: 'Outdated Dependencies',
      severity: 'medium',
      description: 'Using outdated libraries with known vulnerabilities',
      locations: ['package.json', 'requirements.txt', 'Gemfile']
    },
    {
      type: 'Insecure Direct Object Reference',
      severity: 'high',
      description: 'Access control issue allowing unauthorized data access',
      locations: ['/api/user/:id', '/api/account', '/controllers/UserController.js']
    },
    {
      type: 'Cross-Site Request Forgery',
      severity: 'medium',
      description: 'Missing CSRF tokens in form submissions',
      locations: ['/views/form.html', '/public/form.js', '/controllers/FormController.js']
    },
    {
      type: 'Insecure Authentication',
      severity: 'high',
      description: 'Weak password policies and session management',
      locations: ['/auth/login', '/services/AuthService.js', '/models/User.js']
    },
    {
      type: 'Sensitive Data Exposure',
      severity: 'high',
      description: 'Logging sensitive user information',
      locations: ['/services/LoggingService.js', '/middleware/logger.js', '/config/logging.js']
    }
  ];
  
  const vulnerabilities = [];
  
  // Generate random vulnerabilities
  for (let i = 0; i < count; i++) {
    const vulnType = vulnerabilityTypes[Math.floor(Math.random() * vulnerabilityTypes.length)];
    const location = vulnType.locations[Math.floor(Math.random() * vulnType.locations.length)];
    
    vulnerabilities.push({
      id: uuidv4(),
      type: vulnType.type,
      severity: vulnType.severity,
      description: vulnType.description,
      location,
      detectedAt: new Date().toISOString(),
      status: 'open'
    });
  }
  
  return vulnerabilities;
};

module.exports = {
  performScan,
  getScanHistory,
  getScanById,
  getScanProfiles
};