/**
 * Scan Service
 * Handles vulnerability scanning operations
 */

const { v4: uuidv4 } = require('uuid');
const axios = require('axios');
const { exec } = require('child_process');
const util = require('util');
const execPromise = util.promisify(exec);
const fs = require('fs');
const path = require('path');
const zapService = require('./zapService');
const staticAnalysisService = require('./staticAnalysisService');
const githubService = require('./githubService');
const scanProfiles = require('../config/scanProfiles');

// In-memory database for MVP
const scanResults = [];

/**
 * Perform a vulnerability scan on the target
 * @param {string} target - URL or codebase path to scan
 * @param {string} scanType - Type of scan (full, quick, custom)
 * @param {string} profileName - Name of the scan profile to use
 * @param {Object} customParams - Custom scan parameters to override profile defaults
 * @param {string} sourceType - Type of source (url, upload, github)
 * @returns {Object} Scan results
 */
const performScan = async (target, scanType = 'full', profileName = 'webApp', customParams = {}, sourceType = 'url') => {
  try {
    console.log(`Starting ${scanType} scan on ${target} using profile ${profileName}`);
    
    // Generate a unique ID for this scan
    const scanId = uuidv4();
    const timestamp = new Date().toISOString();
    
    // Get scan profile
    const profile = scanProfiles.getScanProfile(profileName);
    
    // Merge custom parameters with profile parameters
    const scanParams = {
      ...profile.params,
      ...customParams
    };
    
    // Create scan result object
    const scanResult = {
      id: scanId,
      target,
      scanType,
      profileName,
      timestamp,
      status: 'in-progress',
      vulnerabilities: [],
      sourceType
    };
    
    // Store in our in-memory database
    scanResults.push(scanResult);
    
    let vulnerabilities = [];
    
    // Determine scan type based on target and source type
    if (sourceType === 'url' && target.startsWith('http')) {
      // Web application scanning with ZAP
      vulnerabilities = await scanWebApplication(target, scanParams, scanId);
    } else if (sourceType === 'github') {
      // GitHub repository scanning
      vulnerabilities = await scanGitHubRepository(target, scanParams, scanId);
    } else if (sourceType === 'upload') {
      // Uploaded codebase scanning
      vulnerabilities = await scanUploadedCodebase(target, scanParams, scanId);
    } else {
      // Local path scanning
      vulnerabilities = await scanLocalCodebase(target, scanParams, scanId);
    }
    
    // Update scan result
    const index = scanResults.findIndex(scan => scan.id === scanId);
    if (index !== -1) {
      scanResults[index].vulnerabilities = vulnerabilities;
      scanResults[index].status = 'completed';
    }
    
    return scanResults[index];
  } catch (error) {
    console.error('Error performing scan:', error);
    
    // Update scan result with error
    const index = scanResults.findIndex(scan => scan.id === scanId);
    if (index !== -1) {
      scanResults[index].status = 'failed';
      scanResults[index].error = error.message;
    }
    
    throw new Error(`Scan failed: ${error.message}`);
  }
};

/**
 * Scan a web application using ZAP
 * @param {string} target - URL to scan
 * @param {Object} scanParams - Scan parameters
 * @param {string} scanId - ID of the scan
 * @returns {Array} Vulnerabilities found
 */
const scanWebApplication = async (target, scanParams, scanId) => {
  try {
    // Check if we should use real scanning or mock data
    const useRealScan = process.env.USE_REAL_SCAN === 'true';
    
    if (useRealScan) {
      // Perform real scan using ZAP
      try {
        // Initialize ZAP session
        await zapService.initializeSession();
        
        // Configure scanners based on profile
        await zapService.configureScanners(scanParams.scanners);
        
        // Set scan policy
        await zapService.setScanPolicy({
          attackStrength: scanParams.attackStrength || 'medium',
          alertThreshold: scanParams.threshold || 'medium'
        });
        
        // Start spider scan
        const spiderResult = await zapService.startSpiderScan(target, {
          maxDepth: scanParams.maxDepth
        });
        
        // Wait for spider scan to complete
        let spiderStatus = { completed: false };
        while (!spiderStatus.completed) {
          await new Promise(resolve => setTimeout(resolve, 5000)); // Wait 5 seconds
          spiderStatus = await zapService.checkScanStatus(spiderResult.scanId, 'spider');
          console.log(`Spider scan progress: ${spiderStatus.progress}`);
          
          // Update scan result with progress
          const index = scanResults.findIndex(scan => scan.id === scanId);
          if (index !== -1) {
            scanResults[index].progress = `Spider scan: ${spiderStatus.progress}`;
          }
        }
        
        // Start AJAX spider if enabled
        if (scanParams.ajaxSpider) {
          await zapService.startAjaxSpiderScan(target);
          
          // Wait for AJAX spider to complete
          let ajaxRunning = true;
          while (ajaxRunning) {
            await new Promise(resolve => setTimeout(resolve, 5000)); // Wait 5 seconds
            ajaxRunning = await zapService.isAjaxSpiderRunning();
            console.log(`AJAX spider running: ${ajaxRunning}`);
            
            // Update scan result with progress
            const index = scanResults.findIndex(scan => scan.id === scanId);
            if (index !== -1) {
              scanResults[index].progress = 'AJAX spider running';
            }
          }
        }
        
        // Start active scan if enabled
        if (scanParams.includeActive) {
          const activeScanResult = await zapService.startActiveScan(target);
          
          // Wait for active scan to complete
          let activeScanStatus = { completed: false };
          while (!activeScanStatus.completed) {
            await new Promise(resolve => setTimeout(resolve, 5000)); // Wait 5 seconds
            activeScanStatus = await zapService.checkScanStatus(activeScanResult.scanId, 'ascan');
            console.log(`Active scan progress: ${activeScanStatus.progress}`);
            
            // Update scan result with progress
            const index = scanResults.findIndex(scan => scan.id === scanId);
            if (index !== -1) {
              scanResults[index].progress = `Active scan: ${activeScanStatus.progress}`;
            }
          }
        }
        
        // Get scan results
        return await zapService.getScanResults();
      } catch (error) {
        console.error('Error performing real scan:', error);
        throw error;
      }
    } else {
      // Use mock data for testing
      return getMockVulnerabilities(scanParams.scanType === 'quick' ? 2 : 5);
    }
  } catch (error) {
    console.error('Error scanning web application:', error);
    throw error;
  }
};

/**
 * Scan a GitHub repository
 * @param {string} repoUrl - GitHub repository URL
 * @param {Object} scanParams - Scan parameters
 * @param {string} scanId - ID of the scan
 * @returns {Array} Vulnerabilities found
 */
const scanGitHubRepository = async (repoUrl, scanParams, scanId) => {
  let cloneDir = null;
  
  try {
    // Update scan result with progress
    const index = scanResults.findIndex(scan => scan.id === scanId);
    if (index !== -1) {
      scanResults[index].progress = 'Cloning repository';
    }
    
    // Clone the repository
    const cloneResult = await githubService.cloneRepository(repoUrl);
    cloneDir = cloneResult.cloneDir;
    
    // Update scan result with progress
    if (index !== -1) {
      scanResults[index].progress = 'Repository cloned, starting analysis';
    }
    
    // Get repository info
    const repoInfo = await githubService.getRepositoryInfo(cloneResult.owner, cloneResult.repo);
    
    // Update scan result with repository info
    if (index !== -1) {
      scanResults[index].repoInfo = repoInfo;
    }
    
    // Analyze the codebase
    const vulnerabilities = await staticAnalysisService.analyzeCodebase(cloneDir, {
      ruleset: scanParams.ruleset
    });
    
    return vulnerabilities;
  } catch (error) {
    console.error('Error scanning GitHub repository:', error);
    throw error;
  } finally {
    // Clean up cloned repository
    if (cloneDir) {
      try {
        await githubService.cleanupRepository(cloneDir);
      } catch (cleanupError) {
        console.error('Error cleaning up repository:', cleanupError);
      }
    }
  }
};

/**
 * Scan an uploaded codebase
 * @param {string} uploadPath - Path to the uploaded file
 * @param {Object} scanParams - Scan parameters
 * @param {string} scanId - ID of the scan
 * @returns {Array} Vulnerabilities found
 */
const scanUploadedCodebase = async (uploadPath, scanParams, scanId) => {
  let extractPath = null;
  
  try {
    // Update scan result with progress
    const index = scanResults.findIndex(scan => scan.id === scanId);
    if (index !== -1) {
      scanResults[index].progress = 'Extracting uploaded file';
    }
    
    // Extract the uploaded file if it's a zip
    if (uploadPath.endsWith('.zip')) {
      const tempDir = path.join(process.env.TEMP_DIR || './temp', `upload-${Date.now()}`);
      extractPath = await staticAnalysisService.extractZipFile(uploadPath, tempDir);
    } else {
      extractPath = uploadPath;
    }
    
    // Update scan result with progress
    if (index !== -1) {
      scanResults[index].progress = 'Starting analysis';
    }
    
    // Analyze the codebase
    const vulnerabilities = await staticAnalysisService.analyzeCodebase(extractPath, {
      ruleset: scanParams.ruleset
    });
    
    return vulnerabilities;
  } catch (error) {
    console.error('Error scanning uploaded codebase:', error);
    throw error;
  } finally {
    // Clean up extracted files
    if (extractPath && extractPath !== uploadPath) {
      try {
        await staticAnalysisService.cleanup(extractPath);
      } catch (cleanupError) {
        console.error('Error cleaning up extracted files:', cleanupError);
      }
    }
  }
};

/**
 * Scan a local codebase
 * @param {string} codebasePath - Path to the codebase
 * @param {Object} scanParams - Scan parameters
 * @param {string} scanId - ID of the scan
 * @returns {Array} Vulnerabilities found
 */
const scanLocalCodebase = async (codebasePath, scanParams, scanId) => {
  try {
    // Update scan result with progress
    const index = scanResults.findIndex(scan => scan.id === scanId);
    if (index !== -1) {
      scanResults[index].progress = 'Starting analysis';
    }
    
    // Analyze the codebase
    const vulnerabilities = await staticAnalysisService.analyzeCodebase(codebasePath, {
      ruleset: scanParams.ruleset
    });
    
    return vulnerabilities;
  } catch (error) {
    console.error('Error scanning local codebase:', error);
    throw error;
  }
};

/**
 * Get scan history
 * @returns {Array} List of past scans
 */
const getScanHistory = async () => {
  // In a real implementation, this would query a database
  return scanResults.map(scan => ({
    id: scan.id,
    target: scan.target,
    scanType: scan.scanType,
    profileName: scan.profileName,
    timestamp: scan.timestamp,
    status: scan.status,
    sourceType: scan.sourceType,
    vulnerabilityCount: scan.vulnerabilities ? scan.vulnerabilities.length : 0
  }));
};

/**
 * Get scan by ID
 * @param {string} scanId - ID of the scan to retrieve
 * @returns {Object} Scan result
 */
const getScanById = async (scanId) => {
  // In a real implementation, this would query a database
  return scanResults.find(scan => scan.id === scanId);
};

/**
 * Get available scan profiles
 * @returns {Array} List of available scan profiles
 */
const getScanProfiles = async () => {
  return scanProfiles.getAllScanProfiles();
};

/**
 * Generate mock vulnerabilities for demo purposes
 * @param {number} count - Number of vulnerabilities to generate
 * @returns {Array} List of mock vulnerabilities
 */
const getMockVulnerabilities = (count) => {
  const vulnerabilityTypes = [
    {
      type: 'SQL Injection',
      severity: 'high',
      description: 'Unsanitized user input in SQL query',
      locations: ['/api/users', '/api/products', '/api/orders']
    },
    {
      type: 'Cross-Site Scripting (XSS)',
      severity: 'medium',
      description: 'Reflected XSS vulnerability in user input',
      locations: ['/views/profile.html', '/views/comments.js', '/public/scripts.js']
    },
    {
      type: 'Outdated Dependencies',
      severity: 'medium',
      description: 'Using outdated libraries with known vulnerabilities',
      locations: ['package.json', 'requirements.txt', 'Gemfile']
    },
    {
      type: 'Insecure Direct Object Reference',
      severity: 'high',
      description: 'Access control issue allowing unauthorized data access',
      locations: ['/api/user/:id', '/api/account', '/controllers/UserController.js']
    },
    {
      type: 'Cross-Site Request Forgery',
      severity: 'medium',
      description: 'Missing CSRF tokens in form submissions',
      locations: ['/views/form.html', '/public/form.js', '/controllers/FormController.js']
    },
    {
      type: 'Insecure Authentication',
      severity: 'high',
      description: 'Weak password policies and session management',
      locations: ['/auth/login', '/services/AuthService.js', '/models/User.js']
    },
    {
      type: 'Sensitive Data Exposure',
      severity: 'high',
      description: 'Logging sensitive user information',
      locations: ['/services/LoggingService.js', '/middleware/logger.js', '/config/logging.js']
    }
  ];
  
  const vulnerabilities = [];
  
  // Generate random vulnerabilities
  for (let i = 0; i < count; i++) {
    const vulnType = vulnerabilityTypes[Math.floor(Math.random() * vulnerabilityTypes.length)];
    const location = vulnType.locations[Math.floor(Math.random() * vulnType.locations.length)];
    
    vulnerabilities.push({
      id: uuidv4(),
      type: vulnType.type,
      severity: vulnType.severity,
      description: vulnType.description,
      location,
      detectedAt: new Date().toISOString(),
      status: 'open',
      tool: 'mock'
    });
  }
  
  return vulnerabilities;
};

module.exports = {
  performScan,
  getScanHistory,
  getScanById,
  getScanProfiles
};