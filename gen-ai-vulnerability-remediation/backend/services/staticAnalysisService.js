/**
 * Static Analysis Service
 * Handles static code analysis for vulnerability detection in codebases
 */

const { exec } = require('child_process');
const util = require('util');
const execPromise = util.promisify(exec);
const fs = require('fs');
const path = require('path');
const { v4: uuidv4 } = require('uuid');

// Configuration
const config = {
  uploadDir: process.env.UPLOAD_DIR || './uploads',
  tempDir: process.env.TEMP_DIR || './temp',
  semgrepEnabled: process.env.SEMGREP_ENABLED === 'true',
  snykEnabled: process.env.SNYK_ENABLED === 'true',
  snykToken: process.env.SNYK_TOKEN || ''
};

/**
 * Run Semgrep analysis on a codebase
 * @param {string} codebasePath - Path to the codebase
 * @param {Object} options - Analysis options
 * @returns {Array} Vulnerabilities found
 */
const runSemgrepAnalysis = async (codebasePath, options = {}) => {
  try {
    if (!config.semgrepEnabled) {
      console.log('Semgrep analysis is disabled');
      return [];
    }

    // Determine which ruleset to use
    const rulesetArg = options.ruleset ? `--config ${options.ruleset}` : '--config auto';
    
    // Run Semgrep with JSON output
    const outputPath = path.join(config.tempDir, `semgrep-results-${Date.now()}.json`);
    
    // Ensure temp directory exists
    if (!fs.existsSync(config.tempDir)) {
      fs.mkdirSync(config.tempDir, { recursive: true });
    }
    
    const command = `semgrep ${rulesetArg} --json ${codebasePath} > ${outputPath}`;
    await execPromise(command);
    
    // Read and parse results
    const rawResults = fs.readFileSync(outputPath, 'utf8');
    const results = JSON.parse(rawResults);
    
    // Clean up
    fs.unlinkSync(outputPath);
    
    // Transform results to standard format
    return results.results.map(result => ({
      id: uuidv4(),
      type: result.check_id,
      severity: mapSemgrepSeverity(result.extra.severity),
      description: result.extra.message,
      location: `${result.path}:${result.start.line}`,
      evidence: result.extra.lines,
      detectedAt: new Date().toISOString(),
      status: 'open',
      tool: 'semgrep',
      cwe: result.extra.metadata?.cwe || [],
      remediation: result.extra.metadata?.fix || ''
    }));
  } catch (error) {
    console.error('Error running Semgrep analysis:', error);
    throw new Error(`Failed to run Semgrep analysis: ${error.message}`);
  }
};

/**
 * Run Snyk analysis on a codebase
 * @param {string} codebasePath - Path to the codebase
 * @param {Object} options - Analysis options
 * @returns {Array} Vulnerabilities found
 */
const runSnykAnalysis = async (codebasePath, options = {}) => {
  try {
    if (!config.snykEnabled) {
      console.log('Snyk analysis is disabled');
      return [];
    }

    if (!config.snykToken) {
      console.log('Snyk token not configured');
      return [];
    }
    
    // Set Snyk token
    process.env.SNYK_TOKEN = config.snykToken;
    
    // Run Snyk with JSON output
    const outputPath = path.join(config.tempDir, `snyk-results-${Date.now()}.json`);
    
    // Ensure temp directory exists
    if (!fs.existsSync(config.tempDir)) {
      fs.mkdirSync(config.tempDir, { recursive: true });
    }
    
    const command = `cd ${codebasePath} && snyk test --json > ${outputPath}`;
    await execPromise(command);
    
    // Read and parse results
    const rawResults = fs.readFileSync(outputPath, 'utf8');
    const results = JSON.parse(rawResults);
    
    // Clean up
    fs.unlinkSync(outputPath);
    
    // Transform results to standard format
    return results.vulnerabilities.map(vuln => ({
      id: uuidv4(),
      type: vuln.title,
      severity: vuln.severity,
      description: vuln.description,
      location: `${vuln.from.join(' > ')}`,
      evidence: vuln.packageName,
      detectedAt: new Date().toISOString(),
      status: 'open',
      tool: 'snyk',
      cwe: vuln.identifiers?.CWE || [],
      remediation: vuln.fixedIn ? `Update to version ${vuln.fixedIn}` : 'No fix available'
    }));
  } catch (error) {
    console.error('Error running Snyk analysis:', error);
    throw new Error(`Failed to run Snyk analysis: ${error.message}`);
  }
};

/**
 * Run static code analysis on a codebase
 * @param {string} codebasePath - Path to the codebase
 * @param {Object} options - Analysis options
 * @returns {Array} Vulnerabilities found
 */
const analyzeCodebase = async (codebasePath, options = {}) => {
  try {
    console.log(`Starting static analysis on ${codebasePath}`);
    
    const vulnerabilities = [];
    
    // Run Semgrep analysis
    if (config.semgrepEnabled) {
      try {
        const semgrepResults = await runSemgrepAnalysis(codebasePath, options);
        vulnerabilities.push(...semgrepResults);
      } catch (error) {
        console.error('Semgrep analysis failed:', error);
      }
    }
    
    // Run Snyk analysis
    if (config.snykEnabled) {
      try {
        const snykResults = await runSnykAnalysis(codebasePath, options);
        vulnerabilities.push(...snykResults);
      } catch (error) {
        console.error('Snyk analysis failed:', error);
      }
    }
    
    return vulnerabilities;
  } catch (error) {
    console.error('Error analyzing codebase:', error);
    throw new Error(`Failed to analyze codebase: ${error.message}`);
  }
};

/**
 * Map Semgrep severity to standard severity
 * @param {string} severity - Semgrep severity
 * @returns {string} Standard severity
 */
const mapSemgrepSeverity = (severity) => {
  const severityMap = {
    'INFO': 'info',
    'WARNING': 'medium',
    'ERROR': 'high'
  };
  
  return severityMap[severity] || 'info';
};

/**
 * Extract a zip file
 * @param {string} zipPath - Path to the zip file
 * @param {string} extractPath - Path to extract to
 * @returns {string} Path to extracted files
 */
const extractZipFile = async (zipPath, extractPath) => {
  try {
    // Ensure extract path exists
    if (!fs.existsSync(extractPath)) {
      fs.mkdirSync(extractPath, { recursive: true });
    }
    
    // Extract zip file
    const command = `unzip -o ${zipPath} -d ${extractPath}`;
    await execPromise(command);
    
    return extractPath;
  } catch (error) {
    console.error('Error extracting zip file:', error);
    throw new Error(`Failed to extract zip file: ${error.message}`);
  }
};

/**
 * Clean up temporary files
 * @param {string} path - Path to clean up
 */
const cleanup = async (path) => {
  try {
    if (fs.existsSync(path)) {
      fs.rmSync(path, { recursive: true, force: true });
    }
  } catch (error) {
    console.error('Error cleaning up:', error);
  }
};

module.exports = {
  analyzeCodebase,
  runSemgrepAnalysis,
  runSnykAnalysis,
  extractZipFile,
  cleanup
};