/**
 * Vulnerability Model
 * Represents a security vulnerability detected in the system
 */

const mongoose = require('mongoose');

const VulnerabilitySchema = new mongoose.Schema({
  scanId: {
    type: String,
    required: true
  },
  type: {
    type: String,
    required: true
  },
  severity: {
    type: String,
    enum: ['low', 'medium', 'high', 'critical'],
    required: true
  },
  description: {
    type: String,
    required: true
  },
  location: {
    type: String,
    required: true
  },
  lineNumber: {
    type: Number
  },
  code: {
    type: String
  },
  detectedAt: {
    type: Date,
    default: Date.now
  },
  status: {
    type: String,
    enum: ['open', 'in_progress', 'fixed', 'false_positive', 'wont_fix'],
    default: 'open'
  },
  fixedAt: {
    type: Date
  },
  fixedBy: {
    type: String
  },
  remediationId: {
    type: String
  }
});

// For MVP, we'll use a mock implementation instead of MongoDB
// This is just to show the schema structure
// In a real implementation, this would be used with MongoDB

// Mock Vulnerability class for MVP
class Vulnerability {
  constructor(data) {
    this.id = data.id || Math.random().toString(36).substring(2, 15);
    this.scanId = data.scanId;
    this.type = data.type;
    this.severity = data.severity;
    this.description = data.description;
    this.location = data.location;
    this.lineNumber = data.lineNumber;
    this.code = data.code;
    this.detectedAt = data.detectedAt || new Date();
    this.status = data.status || 'open';
    this.fixedAt = data.fixedAt;
    this.fixedBy = data.fixedBy;
    this.remediationId = data.remediationId;
  }
  
  // Static methods
  static async findById(id) {
    // Mock implementation
    return mockVulnerabilities.find(vuln => vuln.id === id);
  }
  
  static async findByScanId(scanId) {
    // Mock implementation
    return mockVulnerabilities.filter(vuln => vuln.scanId === scanId);
  }
  
  static async findByStatus(status) {
    // Mock implementation
    return mockVulnerabilities.filter(vuln => vuln.status === status);
  }
  
  // Instance methods
  async save() {
    // Mock implementation
    const existingIndex = mockVulnerabilities.findIndex(vuln => vuln.id === this.id);
    if (existingIndex >= 0) {
      mockVulnerabilities[existingIndex] = this;
    } else {
      mockVulnerabilities.push(this);
    }
    return this;
  }
  
  async markAsFixed(userId) {
    this.status = 'fixed';
    this.fixedAt = new Date();
    this.fixedBy = userId;
    return this.save();
  }
}

// Mock database
const mockVulnerabilities = [
  new Vulnerability({
    id: 'vuln1',
    scanId: 'scan1',
    type: 'SQL Injection',
    severity: 'high',
    description: 'Unsanitized user input in SQL query',
    location: '/api/users',
    lineNumber: 42,
    code: 'const query = "SELECT * FROM users WHERE username = \'" + username + "\'"',
    detectedAt: new Date('2023-03-01'),
    status: 'open'
  }),
  new Vulnerability({
    id: 'vuln2',
    scanId: 'scan1',
    type: 'Cross-Site Scripting (XSS)',
    severity: 'medium',
    description: 'Reflected XSS vulnerability in user input',
    location: '/views/profile.html',
    lineNumber: 23,
    code: 'element.innerHTML = userInput;',
    detectedAt: new Date('2023-03-01'),
    status: 'open'
  }),
  new Vulnerability({
    id: 'vuln3',
    scanId: 'scan2',
    type: 'Outdated Dependencies',
    severity: 'medium',
    description: 'Using outdated libraries with known vulnerabilities',
    location: 'package.json',
    code: '"express": "4.16.0"',
    detectedAt: new Date('2023-03-02'),
    status: 'fixed',
    fixedAt: new Date('2023-03-03'),
    fixedBy: 'user1',
    remediationId: 'rem1'
  })
];

module.exports = Vulnerability;