/**
 * RemediationLog Model
 * Represents a log of remediation actions taken for vulnerabilities
 */

const mongoose = require('mongoose');

const ChangeSchema = new mongoose.Schema({
  file: {
    type: String,
    required: true
  },
  lineStart: {
    type: Number
  },
  lineEnd: {
    type: Number
  },
  before: {
    type: String
  },
  after: {
    type: String
  }
});

const RemediationLogSchema = new mongoose.Schema({
  vulnerabilityId: {
    type: String,
    required: true
  },
  recommendationId: {
    type: String,
    required: true
  },
  userId: {
    type: String
  },
  timestamp: {
    type: Date,
    default: Date.now
  },
  status: {
    type: String,
    enum: ['pending', 'in_progress', 'completed', 'failed'],
    default: 'pending'
  },
  changes: [ChangeSchema],
  verificationStatus: {
    type: String,
    enum: ['pending', 'verified', 'failed'],
    default: 'pending'
  },
  verifiedAt: {
    type: Date
  }
});

// For MVP, we'll use a mock implementation instead of MongoDB
// This is just to show the schema structure
// In a real implementation, this would be used with MongoDB

// Mock RemediationLog class for MVP
class RemediationLog {
  constructor(data) {
    this.id = data.id || Math.random().toString(36).substring(2, 15);
    this.vulnerabilityId = data.vulnerabilityId;
    this.recommendationId = data.recommendationId;
    this.userId = data.userId;
    this.timestamp = data.timestamp || new Date();
    this.status = data.status || 'pending';
    this.changes = data.changes || [];
    this.verificationStatus = data.verificationStatus || 'pending';
    this.verifiedAt = data.verifiedAt;
  }
  
  // Static methods
  static async findById(id) {
    // Mock implementation
    return mockRemediationLogs.find(log => log.id === id);
  }
  
  static async findByVulnerabilityId(vulnerabilityId) {
    // Mock implementation
    return mockRemediationLogs.filter(log => log.vulnerabilityId === vulnerabilityId);
  }
  
  // Instance methods
  async save() {
    // Mock implementation
    const existingIndex = mockRemediationLogs.findIndex(log => log.id === this.id);
    if (existingIndex >= 0) {
      mockRemediationLogs[existingIndex] = this;
    } else {
      mockRemediationLogs.push(this);
    }
    return this;
  }
  
  async markAsCompleted() {
    this.status = 'completed';
    return this.save();
  }
  
  async markAsVerified() {
    this.verificationStatus = 'verified';
    this.verifiedAt = new Date();
    return this.save();
  }
}

// Mock database
const mockRemediationLogs = [
  new RemediationLog({
    id: 'rem1',
    vulnerabilityId: 'vuln3',
    recommendationId: 'rec1',
    userId: 'user1',
    timestamp: new Date('2023-03-03'),
    status: 'completed',
    changes: [
      {
        file: 'package.json',
        lineStart: 10,
        lineEnd: 10,
        before: '"express": "4.16.0"',
        after: '"express": "4.18.2"'
      }
    ],
    verificationStatus: 'verified',
    verifiedAt: new Date('2023-03-03')
  })
];

module.exports = RemediationLog;