const zapService = require('../services/zapService');
const staticAnalysisService = require('../services/staticAnalysisService');
const githubService = require('../services/githubService');
const scanService = require('../services/scanService');

// Mock dependencies
jest.mock('axios');
jest.mock('child_process');
jest.mock('fs');
jest.mock('path');

describe('ZAP Service', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('initializeSession should create a new ZAP session', async () => {
    const axios = require('axios');
    axios.get.mockResolvedValue({ data: { Result: 'OK' } });

    const result = await zapService.initializeSession();
    
    expect(result.success).toBe(true);
    expect(axios.get).toHaveBeenCalledWith(
      expect.stringContaining('/JSON/core/action/newSession/'),
      expect.any(Object)
    );
  });

  test('startSpiderScan should start a spider scan', async () => {
    const axios = require('axios');
    axios.get.mockResolvedValue({ data: { scan: '1' } });

    const result = await zapService.startSpiderScan('http://example.com');
    
    expect(result.scanId).toBe('1');
    expect(result.success).toBe(true);
    expect(axios.get).toHaveBeenCalledWith(
      expect.stringContaining('/JSON/spider/action/scan/'),
      expect.any(Object)
    );
  });

  test('getScanResults should return formatted vulnerabilities', async () => {
    const axios = require('axios');
    axios.get.mockResolvedValue({
      data: {
        alerts: [
          {
            name: 'XSS',
            risk: '3',
            description: 'Cross-site scripting vulnerability',
            solution: 'Sanitize input',
            reference: 'https://example.com',
            url: 'http://example.com/page',
            param: 'query',
            evidence: '<script>',
            cweid: '79',
            wascid: '8'
          }
        ]
      }
    });

    const results = await zapService.getScanResults();
    
    expect(results.length).toBe(1);
    expect(results[0].type).toBe('XSS');
    expect(results[0].severity).toBe('high');
    expect(axios.get).toHaveBeenCalledWith(
      expect.stringContaining('/JSON/core/view/alerts/'),
      expect.any(Object)
    );
  });
});

describe('Static Analysis Service', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('analyzeCodebase should run configured analysis tools', async () => {
    // Mock process.env
    process.env.SEMGREP_ENABLED = 'true';
    process.env.SNYK_ENABLED = 'false';

    // Mock the runSemgrepAnalysis function
    staticAnalysisService.runSemgrepAnalysis = jest.fn().mockResolvedValue([
      {
        id: '1',
        type: 'sql-injection',
        severity: 'high',
        description: 'SQL injection vulnerability',
        location: 'app.js:42',
        evidence: 'query("SELECT * FROM users WHERE id = " + userId)',
        detectedAt: '2023-01-01T00:00:00.000Z',
        status: 'open',
        tool: 'semgrep'
      }
    ]);

    const results = await staticAnalysisService.analyzeCodebase('/path/to/code');
    
    expect(results.length).toBe(1);
    expect(results[0].type).toBe('sql-injection');
    expect(staticAnalysisService.runSemgrepAnalysis).toHaveBeenCalledWith('/path/to/code', expect.any(Object));
  });
});

describe('GitHub Service', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('cloneRepository should clone a GitHub repository', async () => {
    const util = require('util');
    const fs = require('fs');
    
    // Mock execPromise
    util.promisify = jest.fn().mockReturnValue(jest.fn().mockResolvedValue({ stdout: '', stderr: '' }));
    
    // Mock fs.existsSync and fs.mkdirSync
    fs.existsSync = jest.fn().mockReturnValue(false);
    fs.mkdirSync = jest.fn();

    const result = await githubService.cloneRepository('https://github.com/user/repo');
    
    expect(result.success).toBe(true);
    expect(result.owner).toBe('user');
    expect(result.repo).toBe('repo');
    expect(fs.mkdirSync).toHaveBeenCalled();
  });

  test('getRepositoryInfo should fetch repository information', async () => {
    const axios = require('axios');
    axios.get.mockResolvedValue({
      data: {
        id: 123,
        name: 'repo',
        full_name: 'user/repo',
        description: 'A test repository',
        language: 'JavaScript',
        default_branch: 'main',
        stargazers_count: 10,
        forks_count: 5,
        open_issues_count: 2,
        created_at: '2023-01-01T00:00:00Z',
        updated_at: '2023-01-02T00:00:00Z'
      }
    });

    const result = await githubService.getRepositoryInfo('user', 'repo');
    
    expect(result.id).toBe(123);
    expect(result.name).toBe('repo');
    expect(result.language).toBe('JavaScript');
    expect(axios.get).toHaveBeenCalledWith(
      'https://api.github.com/repos/user/repo',
      expect.any(Object)
    );
  });
});

describe('Scan Service', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('performScan should handle web application scanning', async () => {
    // Mock process.env
    process.env.USE_REAL_SCAN = 'true';

    // Mock scanWebApplication
    scanService.scanWebApplication = jest.fn().mockResolvedValue([
      {
        id: '1',
        type: 'XSS',
        severity: 'high',
        description: 'Cross-site scripting vulnerability',
        location: 'http://example.com/page',
        detectedAt: '2023-01-01T00:00:00.000Z',
        status: 'open'
      }
    ]);

    const result = await scanService.performScan('http://example.com', 'full', 'webApp', {}, 'url');
    
    expect(result.status).toBe('completed');
    expect(result.vulnerabilities.length).toBe(1);
    expect(result.vulnerabilities[0].type).toBe('XSS');
    expect(scanService.scanWebApplication).toHaveBeenCalledWith('http://example.com', expect.any(Object), expect.any(String));
  });

  test('performScan should handle GitHub repository scanning', async () => {
    // Mock scanGitHubRepository
    scanService.scanGitHubRepository = jest.fn().mockResolvedValue([
      {
        id: '1',
        type: 'sql-injection',
        severity: 'high',
        description: 'SQL injection vulnerability',
        location: 'app.js:42',
        detectedAt: '2023-01-01T00:00:00.000Z',
        status: 'open'
      }
    ]);

    const result = await scanService.performScan('https://github.com/user/repo', 'full', 'webApp', {}, 'github');
    
    expect(result.status).toBe('completed');
    expect(result.vulnerabilities.length).toBe(1);
    expect(result.vulnerabilities[0].type).toBe('sql-injection');
    expect(scanService.scanGitHubRepository).toHaveBeenCalledWith('https://github.com/user/repo', expect.any(Object), expect.any(String));
  });
});