const express = require('express');
const router = express.Router();
const axios = require('axios');
const { v4: uuidv4 } = require('uuid');
const fs = require('fs');
const path = require('path');
const scanService = require('../services/scanService');

// Mock storage for GitHub tokens (in a real app, this would be in a database)
const githubTokens = new Map();

/**
 * @route   GET /api/github/login
 * @desc    Redirect to GitHub OAuth
 * @access  Public
 */
router.get('/login', (req, res) => {
  try {
    // Generate a state parameter to prevent CSRF attacks
    const state = uuidv4();
    
    // In a real app, store state in session or database
    // For demo, we'll use a cookie
    res.cookie('github_oauth_state', state, { 
      httpOnly: true, 
      maxAge: 10 * 60 * 1000 // 10 minutes
    });
    
    // GitHub OAuth parameters
    const clientId = process.env.GITHUB_CLIENT_ID || 'your-github-client-id';
    const redirectUri = encodeURIComponent(`${req.protocol}://${req.get('host')}/api/github/callback`);
    const scope = encodeURIComponent('repo');
    
    // Redirect to GitHub OAuth
    const authUrl = `https://github.com/login/oauth/authorize?client_id=${clientId}&redirect_uri=${redirectUri}&scope=${scope}&state=${state}`;
    
    res.redirect(authUrl);
  } catch (error) {
    console.error('GitHub login error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to initiate GitHub authentication',
      message: error.message
    });
  }
});

/**
 * @route   GET /api/github/callback
 * @desc    Handle GitHub OAuth callback
 * @access  Public
 */
router.get('/callback', async (req, res) => {
  try {
    const { code, state } = req.query;
    
    // Verify state parameter to prevent CSRF attacks
    const storedState = req.cookies.github_oauth_state;
    
    if (!state || state !== storedState) {
      return res.status(400).json({
        success: false,
        error: 'Invalid state parameter'
      });
    }
    
    // Clear the state cookie
    res.clearCookie('github_oauth_state');
    
    // Exchange code for access token
    const clientId = process.env.GITHUB_CLIENT_ID || 'your-github-client-id';
    const clientSecret = process.env.GITHUB_CLIENT_SECRET || 'your-github-client-secret';
    
    const tokenResponse = await axios.post('https://github.com/login/oauth/access_token', {
      client_id: clientId,
      client_secret: clientSecret,
      code,
      redirect_uri: `${req.protocol}://${req.get('host')}/api/github/callback`
    }, {
      headers: {
        Accept: 'application/json'
      }
    });
    
    const { access_token } = tokenResponse.data;
    
    if (!access_token) {
      throw new Error('Failed to obtain access token');
    }
    
    // Get user info
    const userResponse = await axios.get('https://api.github.com/user', {
      headers: {
        Authorization: `token ${access_token}`
      }
    });
    
    const userId = userResponse.data.id;
    
    // Store token (in a real app, this would be in a database)
    githubTokens.set(userId.toString(), {
      token: access_token,
      username: userResponse.data.login
    });
    
    // Redirect to frontend with user ID
    res.redirect(`${process.env.FRONTEND_URL || 'http://localhost:3000'}?github_user=${userId}`);
  } catch (error) {
    console.error('GitHub callback error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to complete GitHub authentication',
      message: error.message
    });
  }
});

/**
 * @route   GET /api/github/repositories
 * @desc    Get user's GitHub repositories
 * @access  Private (requires GitHub authentication)
 */
router.get('/repositories', async (req, res) => {
  try {
    const { userId } = req.query;
    
    if (!userId || !githubTokens.has(userId)) {
      return res.status(401).json({
        success: false,
        error: 'GitHub authentication required'
      });
    }
    
    const { token } = githubTokens.get(userId);
    
    // Get user's repositories
    const reposResponse = await axios.get('https://api.github.com/user/repos', {
      headers: {
        Authorization: `token ${token}`
      },
      params: {
        sort: 'updated',
        per_page: 100
      }
    });
    
    // Format repository data
    const repositories = reposResponse.data.map(repo => ({
      id: repo.id,
      name: repo.name,
      full_name: repo.full_name,
      description: repo.description,
      default_branch: repo.default_branch,
      url: repo.html_url,
      updated_at: repo.updated_at
    }));
    
    res.status(200).json({
      success: true,
      data: repositories
    });
  } catch (error) {
    console.error('GitHub repositories error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch GitHub repositories',
      message: error.message
    });
  }
});

/**
 * @route   GET /api/github/branches/:owner/:repo
 * @desc    Get branches for a GitHub repository
 * @access  Private (requires GitHub authentication)
 */
router.get('/branches/:owner/:repo', async (req, res) => {
  try {
    const { owner, repo } = req.params;
    const { userId } = req.query;
    
    if (!userId || !githubTokens.has(userId)) {
      return res.status(401).json({
        success: false,
        error: 'GitHub authentication required'
      });
    }
    
    const { token } = githubTokens.get(userId);
    
    // Get repository branches
    const branchesResponse = await axios.get(`https://api.github.com/repos/${owner}/${repo}/branches`, {
      headers: {
        Authorization: `token ${token}`
      }
    });
    
    // Format branch data
    const branches = branchesResponse.data.map(branch => ({
      name: branch.name,
      commit: branch.commit.sha
    }));
    
    res.status(200).json({
      success: true,
      data: branches
    });
  } catch (error) {
    console.error('GitHub branches error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch repository branches',
      message: error.message
    });
  }
});

/**
 * @route   POST /api/github/scan
 * @desc    Scan a GitHub repository
 * @access  Private (requires GitHub authentication)
 */
router.post('/scan', async (req, res) => {
  try {
    const { userId, repository, branch } = req.body;
    
    if (!userId || !githubTokens.has(userId)) {
      return res.status(401).json({
        success: false,
        error: 'GitHub authentication required'
      });
    }
    
    if (!repository || !branch) {
      return res.status(400).json({
        success: false,
        error: 'Repository and branch are required'
      });
    }
    
    const { token, username } = githubTokens.get(userId);
    
    // Parse repository owner and name
    const [owner, repo] = repository.split('/');
    
    // Download repository as zip
    const downloadUrl = `https://api.github.com/repos/${owner}/${repo}/zipball/${branch}`;
    
    const response = await axios({
      method: 'get',
      url: downloadUrl,
      headers: {
        Authorization: `token ${token}`,
        Accept: 'application/vnd.github.v3+json'
      },
      responseType: 'arraybuffer'
    });
    
    // Create directory for downloaded repositories
    const repoDir = path.join(__dirname, '../uploads/github');
    if (!fs.existsSync(repoDir)) {
      fs.mkdirSync(repoDir, { recursive: true });
    }
    
    // Save zip file
    const zipPath = path.join(repoDir, `${owner}-${repo}-${branch}.zip`);
    fs.writeFileSync(zipPath, response.data);
    
    // Extract zip file
    const extractDir = path.join(repoDir, `${owner}-${repo}-${branch}`);
    if (fs.existsSync(extractDir)) {
      fs.rmSync(extractDir, { recursive: true, force: true });
    }
    fs.mkdirSync(extractDir, { recursive: true });
    
    // In a real app, use a library like adm-zip to extract the zip file
    // For demo purposes, we'll assume the extraction is successful
    
    // Initiate scan
    const scanResult = await scanService.performScan(extractDir, 'full');
    
    res.status(200).json({
      success: true,
      message: 'Repository downloaded and scan initiated',
      scanId: scanResult.id
    });
  } catch (error) {
    console.error('GitHub scan error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to scan GitHub repository',
      message: error.message
    });
  }
});

module.exports = router;